r"""GUI allowing to control the electroLABOT.

Compile the GUI:

pyinstaller.exe -F --clean  --add-data './data/;data'
-n "name" --windowed
--icon=package_data/logo.ico .\gui_main.pyw
"""
import ctypes
import json
import multiprocessing as mp
import os
import re
import sys
import threading
import traceback
import warnings
from time import sleep, perf_counter_ns
from functools import partial

import websocket
# import git

# pylint: disable=E0611
from PyQt6.QtCore import (
    pyqtSlot,
    Qt,
    pyqtSignal,
    QObject,
    QThreadPool,
    QRunnable,
)
from PyQt6.QtGui import (
    QIcon,
    QColor,
    QCloseEvent,
    QValidator,
)
from PyQt6.QtWidgets import (
    QApplication,
    QMainWindow,
    QColorDialog,
)

warnings.simplefilter("ignore", UserWarning)
sys.coinit_flags = 2

# Import Ui_MainWindow class from UiMainApp.py generated by uic module
# from gui_anonymiser_main import Ui_MainWindow  # noqa: E402
from vue_principale import Ui_MainWindow  # noqa: E402
# from gui_anonymiser_settings import Ui_Settings_dialog  # noqa: E402
from utils import (  # noqa E402
    ensure_path,
    flash,
    resource_path,
    split_keep_sep,
    XStream,
)

check_state_converter = {
    Qt.CheckState.Unchecked: 0,
    Qt.CheckState.PartiallyChecked: 1,
    Qt.CheckState.Checked: 2,
    0: Qt.CheckState.Unchecked,
    1: Qt.CheckState.PartiallyChecked,
    2: Qt.CheckState.Checked
}


def exe_path():
    """ Return the path of the executable or of the script. """
    if hasattr(sys, 'frozen'):
        return os.path.dirname(os.path.abspath(sys.executable))
    return os.path.dirname(os.path.abspath(__file__))


SCRIPT_PATH = exe_path()
PREFERENCES_PATH = 'config.json'
PREFERENCES_PATH = os.path.join(SCRIPT_PATH, 'data', PREFERENCES_PATH)


class QIntValidatorFixup(QValidator):
    def __init__(self, minimum, maximum, parent):
        QValidator.__init__(self, parent)
        self.minimum = minimum
        self.maximum = maximum

    def validate(self, string, pos):
        if not string.isdigit() and string != '':
            return (QValidator.State.Invalid, string, pos)

        if string.isdigit() and not (self.minimum <= int(string) <= self.maximum):
            if int(string) < self.minimum:
                return (QValidator.State.Acceptable, str(self.minimum), pos)
            return (QValidator.State.Acceptable, str(self.maximum), pos)

        return (QValidator.State.Acceptable, str(int(string)) if string.isdigit() else '', pos)

    def fixup(self, string):
        return str(int(string))

# Worker class for the QThread handler
# https://stackoverflow.com/questions/50855210/how-to-pass-parameters-into-qrunnable-for-PyQt6


class Worker(QRunnable):  # pylint: disable=too-few-public-methods
    """Worker class to run a function in a QThread."""

    def __init__(self, function, *args, **kwargs):
        super().__init__()
        # Store constructor arguments (re-used for processing)
        self.function = function
        self.args = args
        self.kwargs = kwargs

    @pyqtSlot()
    def run(self):
        """Run the function in the worker."""
        self.function(*self.args, **self.kwargs)


class MainApp(QMainWindow, Ui_MainWindow):
    """
    MainApp class inherit from QMainWindow and from
    Ui_MainWindow class in UiMainApp module.
    """
    progress_changed = pyqtSignal(int)
    progress_text_changed = pyqtSignal(str)
    progress_style_changed = pyqtSignal(str)
    # state_changed = pyqtSignal(bool)
    change_main_window_title = pyqtSignal(str)
    change_distance_sensor_value = pyqtSignal(str)
    change_state_button_1 = pyqtSignal(str)
    change_state_button_2 = pyqtSignal(str)
    flash_button_changed = pyqtSignal(bool)
    # show_qmessagebox_exception = pyqtSignal(dict)
    set_wait_cursor = pyqtSignal()  # type(None)
    set_restore_cursor = pyqtSignal()
    leds_colors = {
        0: QColor(255, 255, 0),
        1: QColor(255, 0, 0),
        2: QColor(0, 255, 0),
        3: QColor(0, 0, 255),
    }

    keys_events = dict()
    lock_keys_events = mp.Lock()
    pressed_keys = {}
    lock_pressed_keys = mp.Lock()
    command_queue = mp.Queue(1000)

    def __init__(self):
        """Constructor or the initialiser."""
        QMainWindow.__init__(self)
        # It is imperative to call self.setupUi (self) to initialise the GUI
        # This is defined in gui_autogenerated_template.py file automatically
        self.setupUi(self)
        self.groupBox_3.setVisible(False)

        self.leds_colors_spin_boxes = {
            0: {
                'r': self.spinBox_rgb_0_r,
                'g': self.spinBox_rgb_0_g,
                'b': self.spinBox_rgb_0_b,
            },
            1: {
                'r': self.spinBox_rgb_1_r,
                'g': self.spinBox_rgb_1_g,
                'b': self.spinBox_rgb_1_b,
            },
            2: {
                'r': self.spinBox_rgb_2_r,
                'g': self.spinBox_rgb_2_g,
                'b': self.spinBox_rgb_2_b,
            },
            3: {
                'r': self.spinBox_rgb_3_r,
                'g': self.spinBox_rgb_3_g,
                'b': self.spinBox_rgb_3_b,
            },
        }
        self.base_title = 'electroLABOT - Télécommande'
        self.setWindowTitle(f'{self.base_title}')
        # Maximize the window
        # self.showMaximized()

        # Set editable line to read only.
        # self.destination.setReadOnly(True)

        # Add validators to text fields
        self.lineEdit_ip_0.setValidator(QIntValidatorFixup(0, 255, self))
        self.lineEdit_ip_1.setValidator(QIntValidatorFixup(0, 255, self))
        self.lineEdit_ip_2.setValidator(QIntValidatorFixup(0, 255, self))
        self.lineEdit_ip_3.setValidator(QIntValidatorFixup(0, 255, self))
        self.lineEdit_port.setValidator(QIntValidatorFixup(0, 65535, self))

        # Set progress bar and slots
        self.progress_changed.connect(self.progress_bar.setValue)
        self.progress_changed.emit(0)
        self.progress_bar.setFormat('Inactif')
        self.progress_bar.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.progress_text_changed.connect(self.progress_bar.setFormat)
        self.progress_style_changed.connect(self.progress_bar.setStyleSheet)
        self.flash_button.clicked.connect(self.flash_electrolabbot)
        self.flash_button_changed.connect(self.flash_button.setEnabled)

        # Configure qmessagebox for exception via signals
        # self.show_qmessagebox_exception.connect(self.show_critical_exception)

        # Change cursor using pyqtSignal
        self.set_wait_cursor.connect(
            lambda: QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor),
        )
        self.set_restore_cursor.connect(QApplication.restoreOverrideCursor)

        self.load_preferences()

        # Colour pickers
        self.colour_picker_0.clicked.connect(
            partial(self.show_colour_picker, index=0))
        self.colour_picker_1.clicked.connect(
            partial(self.show_colour_picker, index=1))
        self.colour_picker_2.clicked.connect(
            partial(self.show_colour_picker, index=2))
        self.colour_picker_3.clicked.connect(
            partial(self.show_colour_picker, index=3))

        self.spinBox_rgb_0_r.valueChanged.connect(
            lambda: self.update_colours(0))
        self.spinBox_rgb_0_g.valueChanged.connect(
            lambda: self.update_colours(0))
        self.spinBox_rgb_0_b.valueChanged.connect(
            lambda: self.update_colours(0))
        self.spinBox_rgb_1_r.valueChanged.connect(
            lambda: self.update_colours(1))
        self.spinBox_rgb_1_g.valueChanged.connect(
            lambda: self.update_colours(1))
        self.spinBox_rgb_1_b.valueChanged.connect(
            lambda: self.update_colours(1))
        self.spinBox_rgb_2_r.valueChanged.connect(
            lambda: self.update_colours(2))
        self.spinBox_rgb_2_g.valueChanged.connect(
            lambda: self.update_colours(2))
        self.spinBox_rgb_2_b.valueChanged.connect(
            lambda: self.update_colours(2))
        self.spinBox_rgb_3_r.valueChanged.connect(
            lambda: self.update_colours(3))
        self.spinBox_rgb_3_g.valueChanged.connect(
            lambda: self.update_colours(3))
        self.spinBox_rgb_3_b.valueChanged.connect(
            lambda: self.update_colours(3))

        # Set the bip button
        self.buzzer_button.pressed.connect(self.buzzer_button_pressed)
        self.buzzer_button.released.connect(self.buzzer_button_released)

        # Set distance angle sensor and buttons slots and signals
        self.slider_ultrasonic_sensor_angle.valueChanged.connect(
            self.distance_sensor_angle_changed)
        self.change_distance_sensor_value.connect(self.distance_label.setText)
        self.change_state_button_1.connect(self.state_button_1.setText)
        self.change_state_button_2.connect(self.state_button_2.setText)

        # Parameters
        self.Appliquer.clicked.connect(self.save_preferences)
        self.Annuler.clicked.connect(self.load_preferences)

        # Save preferences
        self.led_builtin_on.clicked.connect(
            partial(self.save_preferences, led_builtin=True))
        self.led_builtin_off.clicked.connect(
            partial(self.save_preferences, led_builtin=True))

        # self.actionAbout.triggered.connect(self.show_about)
        # self.actionOnline_documentation.triggered.connect(
        #     self.open_documentation)
        # self.actionSelect_file_s.triggered.connect(self.select_files_browser)
        # self.actionSelect_folder.triggered.connect(self.select_folder_browser)
        # self.actionSettings.triggered.connect(
        #     self.show_settings)
        # self.tool_source.clicked.connect(self.select_files_browser)
        # self.tool_destination.clicked.connect(
        #     self.select_destination_folder_browser)

        # # List View
        # self.source_list_model = QStandardItemModel()
        # self.source.setModel(self.source_list_model)
        # self.source.setEditTriggers(
        #     QAbstractItemView.EditTrigger.NoEditTriggers)

        # Create a QThread to avoid to hang the main process
        self.threadpool = QThreadPool()
        self.threadpool.setMaxThreadCount(4)
        self.event_stop = threading.Event()
        self.key_event_worker = Worker(self.keys_events_process)
        self.threadpool.start(self.key_event_worker)
        self.change_main_window_title.connect(self.setWindowTitle)
        self.app_websocket = websocket.WebSocket()
        self.websocket_worker = Worker(self.websocket_process)
        self.threadpool.start(self.websocket_worker)
        self.websocket_received_message_worker = Worker(
            self.websocket_received_message_process)
        self.threadpool.start(self.websocket_received_message_worker)
        self.console_worker = Worker(self._flash)

        # Create a "console"
        # This buffer will keep the last line ...\n
        self.lastline_raw_buffer = ''
        # This one allows to avoid to write two times the same content
        self.lastline_list = ['']
        # Install the custom output stream
        XStream.stdout().message_written.connect(self.data_ready)
        XStream.stderr().message_written.connect(self.data_ready)

        # Don't allow the user to move the cursor
        self.console.setReadOnly(True)

    def data_ready(self, text: str):
        """Insert the text in the console widget.

        Args:
            self: self.
            text: the text to add to the console.
        """
        cursor = self.console.textCursor()
        # Well I don't want to deal with that
        lines = text.replace('\r\n', '\n')
        lines = split_keep_sep(lines, '\n')

        for line in lines:
            # print(line, file=sys.__stdout__)

            if line != '' and line != '\n':
                regex = '([0-9]+)[\\s]+%'
                match = re.findall(regex, line)
                progress = -1

                if match:
                    progress = int(match[-1])
                # print(f'{line = }', file=sys.__stdout__)
                # print(progress, file=sys.__stdout__)

                if progress != -1:
                    self.progress_changed.emit(progress)
                    self.progress_text_changed.emit(
                        f'Programmation en cours... ({progress}%)')
                else:  # 'Success!' in line:
                    self.progress_changed.emit(0)
                    self.progress_text_changed.emit('Inactif')

            # Append line to the last raw line
            self.lastline_raw_buffer += line

            # Only takes the last line
            sep = split_keep_sep(self.lastline_raw_buffer, '\n')

            # Avoid to print two time the same line
            if self.lastline_list == sep:
                return

            self.lastline_list = sep

            # Extract last line to display
            if sep[-1] == '' and len(sep) > 1:
                self.lastline_raw_buffer = sep[-2]

            else:
                self.lastline_raw_buffer = sep[-1]

            # Emulate the carrierage return behaviour
            if '\r' in self.lastline_raw_buffer:
                cursor.movePosition(cursor.MoveOperation.End)
                # https://stackoverflow.com/a/19237185/10949679
                cursor.select(cursor.SelectionType.LineUnderCursor)
                cursor.removeSelectedText()

                temp = ['']

                if self.lastline_raw_buffer.endswith('\n'):
                    fragments = self.lastline_raw_buffer[:-1].split('\r')

                else:
                    fragments = self.lastline_raw_buffer.split('\r')

                for fragment in fragments:
                    for index, frag in enumerate([fragment]):
                        try:
                            temp[index] = frag

                        except IndexError:
                            temp.append(frag)

                line = ''.join(temp)

            cursor.movePosition(cursor.MoveOperation.End)
            cursor.insertText(line)

            # Add the newline if necessary
            if self.lastline_raw_buffer.endswith('\n'):
                if '\r' in self.lastline_raw_buffer:
                    cursor.insertText('\n')
                cursor.movePosition(cursor.MoveOperation.End)

            # Make the cursor visible
            self.console.ensureCursorVisible()
            self.console.setTextCursor(cursor)

    def closeEvent(self, a0: QCloseEvent) -> None:
        """Close everything cleanly."""
        self.event_stop.set()
        return super().closeEvent(a0)

    def keyPressEvent(self, event) -> None:  # pylint: disable=C0103
        """Intercept the key events.

        Args:
            self: self.
            event: the intercepted event.
        """
        # Close the program
        if event.key() == Qt.Key.Key_Escape:
            self.close()

        # Maximize the window
        if event.key() == Qt.Key.Key_F11:
            if self.isMaximized():
                self.showNormal()
            else:
                self.showMaximized()

        self.lock_keys_events.acquire()
        self.keys_events[event.key()] = {
            'time': perf_counter_ns(),
            'pressed': True}

        self.lock_keys_events.release()

    def keyReleaseEvent(self, event) -> None:  # pylint: disable=C0103
        """Intercept the key events."""
        self.lock_keys_events.acquire()
        self.keys_events[event.key()] = {
            'time': perf_counter_ns(),
            'pressed': False}
        self.lock_keys_events.release()

    def keys_events_process(self) -> None:  # pylint: disable=R0201
        """Process the keys events."""
        old_pressed_keys = set()
        old_command_keys = set()
        command_keys = set()

        while not self.event_stop.is_set():
            self.lock_keys_events.acquire()
            self.lock_pressed_keys.acquire()
            self.pressed_keys = {
                key for key, value in self.keys_events.items() if value['pressed']}

            if old_pressed_keys != self.pressed_keys:
                old_pressed_keys = self.pressed_keys

            command_keys = set()
            if Qt.Key.Key_7 in self.pressed_keys or Qt.Key.Key_Home in self.pressed_keys:
                command_keys.add('forward_left')
                self.forward_left.click()
            elif Qt.Key.Key_1 in self.pressed_keys or Qt.Key.Key_End in self.pressed_keys:
                command_keys.add('backward_left')

            if Qt.Key.Key_9 in self.pressed_keys or Qt.Key.Key_PageUp in self.pressed_keys:
                command_keys.add('forward_right')
            elif Qt.Key.Key_3 in self.pressed_keys or Qt.Key.Key_PageDown in self.pressed_keys:
                command_keys.add('backward_right')

            # Left/Right
            if Qt.Key.Key_4 in self.pressed_keys or Qt.Key.Key_Left in self.pressed_keys:
                command_keys = set()
                command_keys.add('forward_right')
                command_keys.add('backward_left')
            elif Qt.Key.Key_6 in self.pressed_keys or Qt.Key.Key_Right in self.pressed_keys:
                command_keys = set()
                command_keys.add('forward_left')
                command_keys.add('backward_right')

            # Forward/Backward
            if Qt.Key.Key_8 in self.pressed_keys or Qt.Key.Key_Up in self.pressed_keys:
                command_keys.clear()
                command_keys.add('forward_left')
                command_keys.add('forward_right')
            elif Qt.Key.Key_2 in self.pressed_keys or Qt.Key.Key_Down in self.pressed_keys:
                command_keys = set()
                command_keys.add('backward_left')
                command_keys.add('backward_right')

            if command_keys != old_command_keys:
                self.command_queue.put(self.command_encoder(command_keys))
                old_command_keys = command_keys

            self.lock_pressed_keys.release()
            self.lock_keys_events.release()
            sleep(0.025)

    def websocket_process(self):
        while not self.event_stop.is_set():
            try:
                preferences = json.load(
                    open(resource_path(PREFERENCES_PATH), 'r'))
                ip_address = preferences.get('ip_address', '192.168.100.1')
                port = preferences.get("port", 42)
                websocket_url = f'ws://{ip_address}:{port}/ws'
                self.change_main_window_title.emit(
                    f'{self.base_title} - {ip_address}:{port} - Connexion...')

                # websocket.enableTrace(True)
                self.app_websocket.connect(websocket_url)

                self.change_main_window_title.emit(
                    f'{self.base_title} - {ip_address}:{port} - Connecté')

                # Set RGB LED on connection
                rgb_leds = []
                for index in range(4):
                    rgb = preferences.get(f'rgb_{index}', [0, 0, 0])
                    rgb_leds.append(f'"rgb_{index}": {rgb}')
                rgb_leds = f'{{{", ".join(rgb_leds)}}}'
                self.app_websocket.send(rgb_leds)

                # Set builtin LED on connection
                led_builtin_state = preferences.get('led_builtin', True)
                led_builtin_state = 'true' if led_builtin_state else 'false'
                self.app_websocket.send(
                    f'{{"led_builtin": {led_builtin_state}}}')
                sleep(1)

                while not self.event_stop.is_set():
                    # Send the command
                    command = self.command_queue.get()
                    print(command, file=sys.__stdout__)
                    if command:
                        self.app_websocket.send(str(command))

                    # Receive the response
            except Exception:
                self.change_main_window_title.emit(
                    f'{self.base_title} - {ip_address}:{port} - Déconnecté')
                print(traceback.format_exc(), file=sys.__stderr__)
                sleep(1)

    def websocket_received_message_process(self):
        while not self.event_stop.is_set():
            try:
                received_message = self.app_websocket.recv()
                json_message = json.loads(received_message)

                if 'distance' in json_message:
                    distance = json_message["distance"]
                    if distance == 501:
                        distance = 'erreur'
                    self.change_distance_sensor_value.emit(
                        f'{distance}'.replace('.', ','))

                if 'button_1' in json_message:
                    self.change_state_button_1.emit(
                        f'{json_message["button_1"]}')

                if 'button_2' in json_message:
                    self.change_state_button_2.emit(
                        f'{json_message["button_2"]}')

            except websocket._exceptions.WebSocketConnectionClosedException:
                sleep(1)

    def flash_electrolabbot(self):
        self.flash_button_changed.emit(False)
        self.threadpool.start(self.console_worker)

    def _flash(self):
        """Flash the ESP32.

        - Disable the buttons
        - Flashes the ESP32
        - Enable the buttons
        """

        command = ['--chip',
                   'esp32',
                   '--baud',
                   '921600',
                   '--before',
                   'default_reset',
                   '--after',
                   'hard_reset',
                   'write_flash',
                   '-z',
                   '--flash_mode',
                   'dio',
                   '--flash_freq',
                   '80m',
                   '--flash_size',
                   'detect',
                   '0x10000',
                   resource_path('package_data\\firmware.bin'),
                   ]

        # print('Using command %s' % ' '.join(command))
        print('Start flashing...')

        try:
            if flash(command):
                print('Success!\n')
            else:
                print('Fail!\n')

        except OSError:
            print('\nUnexpected error (check port connection).\n')

        self.flash_button_changed.emit(True)

    def buzzer_button_pressed(self):
        self.command_queue.put(f'{{ "buzzer": true }}')

    def buzzer_button_released(self):
        self.command_queue.put(f'{{ "buzzer": false }}')

    def distance_sensor_angle_changed(self, angle):
        self.command_queue.put(f'{{ "distance_sensor_angle": {90 - angle} }}')

    def show_colour_picker(self, index: int = 0) -> None:
        colour = QColorDialog.getColor(self.leds_colors[index])

        if colour.isValid():
            self.leds_colors[index] = colour
            self.leds_colors_spin_boxes[index]['r'].setValue(colour.red())
            self.leds_colors_spin_boxes[index]['g'].setValue(colour.green())
            self.leds_colors_spin_boxes[index]['b'].setValue(colour.blue())
            self.save_preferences(colour_index=index, colour=colour)

    def update_colours(self, index) -> None:
        self.leds_colors[index] = QColor(
            self.leds_colors_spin_boxes[index]['r'].value(),
            self.leds_colors_spin_boxes[index]['g'].value(),
            self.leds_colors_spin_boxes[index]['b'].value(),
        )
        self.save_preferences(colour_index=index,
                              colour=self.leds_colors[index])

    def command_encoder(self, command: set) -> dict:
        """Encode the command.

        Args:
            self: self.
            command: the command to encode.

        Returns:
            The encoded command.
        """
        preferences = json.load(open(resource_path(PREFERENCES_PATH)))

        # Are the motors inversed?
        left_motor = 'motor_a' if preferences['inverse_motors'] == False else 'motor_b'
        right_motor = 'motor_b' if preferences['inverse_motors'] == False else 'motor_a'

        command_encoded = {}
        if 'forward_left' in command:
            command_encoded[left_motor] = - \
                preferences['left_high_backward'] if preferences['inverse_left_motor_direction'] else preferences['left_high_forward']
        elif 'backward_left' in command:
            command_encoded[left_motor] = preferences['left_high_forward'] if preferences[
                'inverse_left_motor_direction'] else - preferences['left_high_backward']
        else:
            command_encoded[left_motor] = 0

        if 'forward_right' in command:
            command_encoded[right_motor] = - \
                preferences['right_high_backward'] if preferences['inverse_right_motor_direction'] else preferences['right_high_forward']
        elif 'backward_right' in command:
            command_encoded[right_motor] = preferences['right_high_forward'] if preferences[
                'inverse_right_motor_direction'] else - preferences['right_high_backward']
        else:
            command_encoded[right_motor] = 0

        return {'motor_a': command_encoded['motor_a'], 'motor_b': command_encoded['motor_b']}

    # def set_application_busy(self, state=False):
    #     """ Enable and disable elements. """
    #     self.Cancel.setEnabled(state)
    #     self.OK.setEnabled(not state)
    #     self.fields.setEnabled(not state)
    #     self.Source_box.setEnabled(not state)
    #     self.Destination_box.setEnabled(not state)

    #         self.show_qmessagebox_exception.emit(
    #             {
    #                 'title': (
    #                     'Failed conversion'
    #                 ),
    #                 'text': (
    #                     'One or more files have not be converted to .edf.'
    #                 ),
    #                 'detailed_text': f'\n{not_converted}'
    #             }
    #         )

    # def open_documentation(self):
    #     """Open program documentation."""
    #     try:
    #         from gui_anonymiser_main import REPOSITORY_URL
    #         url = QUrl(REPOSITORY_URL)
    #     except Exception:
    #         url = QUrl('https://github.com/Vincent-Stragier/'
    #                    'deltamed_coherence_openutils')

    #     QDesktopServices.openUrl(url)

    # def show_about(self):
    #     """Show the about me."""
    #     msg = QMessageBox()
    #     msg.setWindowTitle('About')
    #     msg.setText(
    #         'This program has been made by Vincent Stragier.\n\n'
    #         'It has been created to anonymise .eeg (coh3) '
    #         'files from Deltamed (a Natus company) and to convert them to .edf'
    #         ' (European Data Format).\n\n'
    #         'The program (PyQt6 GUI) is under a GNU GPL and its '
    #         'source code is in part under a '
    #         'Creative Commons licence.'
    #     )
    #     msg.setStandardButtons(QMessageBox.StandardButton.Ok)
    #     msg.exec()

    # def show_overwrite_warning(self, message):
    #     """Show the overwrite warning."""
    #     msg = QMessageBox()
    #     msg.setWindowTitle('Overwriting Warning')
    #     msg.setIcon(QMessageBox.Icon.Warning)
    #     msg.setText(
    #         f'{message}\n\nDo you want to continue and overwrite the file(s)?'
    #     )
    #     msg.setStandardButtons(
    #         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.Cancel
    #     )
    #     return msg.exec()

    # def show_critical_exception(self, parameters):
    #     """Show generic error."""
    #     msg = QMessageBox()
    #     msg.setWindowTitle(parameters.get('title', 'Unexpected error'))
    #     msg.setIcon(QMessageBox.Icon.Critical)

    #     text = parameters.get('text', None)
    #     detailed_text = parameters.get('detailed_text', None)
    #     if text is not None:
    #         msg.setText(text)
    #     if detailed_text is not None:
    #         msg.setDetailedText(detailed_text)
    #     msg.setStandardButtons(QMessageBox.StandardButton.Ok)
    #     return msg.exec()

    # def select_files_browser(self):
    #     """Show the files browser."""
    #     dialog = QFileDialog(self)
    #     dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptOpen)
    #     dialog.setDirectory(self.path)
    #     dialog.setFileMode(QFileDialog.FileMode.ExistingFiles)
    #     # Filetype:
    #     # http://justsolve.archiveteam.org/wiki/NII
    #     # https://stackoverflow.com/a/27994762
    #     filters = ["Deltamed EEG files (*.eeg)", "All Files (*)"]
    #     dialog.setNameFilters(filters)
    #     dialog.selectNameFilter(filters[0])
    #     dialog.setOption(QFileDialog.Option.ShowDirsOnly, False)
    #     dialog.setViewMode(QFileDialog.ViewMode.Detail)

    #     if dialog.exec() == QFileDialog.DialogCode.Accepted:
    #         self.OK.setEnabled(False)
    #         self.files = [
    #             os.path.realpath(file_) for file_ in dialog.selectedFiles()
    #         ]
    #         filenames = sorted([
    #             f'{os.path.basename(file_)}' for file_ in self.files])

    #         self.source_list_model.clear()
    #         for filename in filenames:
    #             item = QStandardItem()
    #             item.setText(filename)
    #             item.setIcon(QIcon(resource_path('package_data/file.svg')))
    #             self.source_list_model.appendRow(item)

    #         self.OK.setEnabled(True)
    #         self.path = os.path.dirname(self.files[0])
    #         self.save_preferences(self.path)
    #         self.progress_bar.setValue(0)
    #         if self.destination.text() == '':
    #             self.destination.setText(self.path)

    # def select_folder_browser(self):
    #     """Show the files browser."""
    #     dialog = QFileDialog(self)
    #     dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptOpen)
    #     dialog.setDirectory(self.path)
    #     dialog.setFileMode(QFileDialog.FileMode.Directory)
    #     dialog.setViewMode(QFileDialog.ViewMode.Detail)

    #     if dialog.exec() == QFileDialog.DialogCode.Accepted:
    #         self.source_list_model.clear()
    #         self.OK.setEnabled(False)
    #         folder = dialog.selectedFiles()[0]
    #         worker = Worker(self.validate_folder_contains_eeg, folder)
    #         self.threadpool.start(worker)

    # def validate_folder_contains_eeg(self, folder):
    #     """Check that the folder contains .eeg files."""
    #     self.set_wait_cursor.emit()
    #     self.files = sorted(
    #         [
    #             os.path.realpath(eeg) for eeg in list_files(folder)
    #             if eeg.lower().endswith('.eeg')
    #         ],
    #         key=os.path.basename,
    #     )

    #     if self.files:
    #         self.source_list_model.clear()
    #         item = QStandardItem()
    #         item.setText(folder)
    #         item.setIcon(QIcon(resource_path('package_data/folder.svg')))
    #         self.source_list_model.appendRow(item)

    #         self.path = folder
    #         self.save_preferences(self.path)
    #         self.progress_bar.setValue(0)
    #         if self.destination.text() == '':
    #             self.destination.setText(self.path)

    #         self.OK.setEnabled(True)
    #         self.set_restore_cursor.emit()
    #     else:
    #         self.set_restore_cursor.emit()
    #         self.show_qmessagebox_exception.emit(
    #             {
    #                 'title': (
    #                     'No .eeg files detected in the selected folder.'),
    #                 'text': (
    #                     'No .eeg files have been detected in the selected'
    #                     ' folder. Please select another folder.'),
    #             }
    #         )

    # def show_settings(self):
    #     """Show the setting dialog window."""
    #     dialog = SettingsWindow(self, self.executable_path)
    #     if dialog.exec() == dialog.DialogCode.Accepted:
    #         self.save_preferences(
    #             path=self.path, executable_path=dialog.path_to_executable)

    # def select_destination_folder_browser(self):
    #     """Show the files browser to select the destination."""
    #     dialog = QFileDialog(self)
    #     dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptOpen)
    #     dialog.setDirectory(self.path)
    #     dialog.setFileMode(QFileDialog.FileMode.Directory)

    #     if dialog.exec() == QFileDialog.DialogCode.Accepted:
    #         folder = dialog.selectedFiles()[0]
    #         self.destination.setText(folder)

    def load_preferences(self):
        """ Load the saved preferences from file. """
        try:
            preferences = json.load(open(resource_path(PREFERENCES_PATH)))

            self.pwm_max_value.setValue(preferences.get('pwm_max_value', 4096))
            self.checkBox_inverse_motors.setChecked(
                preferences.get('inverse_motors', False))
            self.checkBox_inverse_left_motor_direction.setChecked(
                preferences.get('inverse_left_motor_direction', False))
            self.checkBox_inverse_right_motor_direction.setChecked(
                preferences.get('inverse_right_motor_direction', False))

            self.spinBox_left_low_forward.setMaximum(
                self.pwm_max_value.value())
            self.spinBox_left_low_backward.setMaximum(
                self.pwm_max_value.value())
            self.spinBox_left_high_forward.setMaximum(
                self.pwm_max_value.value())
            self.spinBox_left_high_backward.setMaximum(
                self.pwm_max_value.value())
            self.spinBox_left_low_forward.setValue(
                preferences.get('left_low_forward', 0))
            self.spinBox_left_low_backward.setValue(
                preferences.get('left_low_backward', 0))

            self.spinBox_left_high_forward.setValue(preferences.get(
                'left_high_forward', self.pwm_max_value.value()))
            self.spinBox_left_high_backward.setValue(preferences.get(
                'left_high_backward', self.pwm_max_value.value()))

            self.spinBox_right_low_forward.setMaximum(
                self.pwm_max_value.value())
            self.spinBox_right_low_backward.setMaximum(
                self.pwm_max_value.value())
            self.spinBox_right_high_forward.setMaximum(
                self.pwm_max_value.value())
            self.spinBox_right_high_backward.setMaximum(
                self.pwm_max_value.value())
            self.spinBox_right_low_forward.setValue(
                preferences.get('right_low_forward', 0))
            self.spinBox_right_low_backward.setValue(
                preferences.get('right_low_backward', 0))
            self.spinBox_right_high_forward.setValue(preferences.get(
                'right_high_forward', self.pwm_max_value.value()))
            self.spinBox_right_high_backward.setValue(preferences.get(
                'right_high_backward', self.pwm_max_value.value()))

            self.lineEdit_port.setText(preferences.get('port', 42))
            ip = preferences.get('ip_address', '192.168.0.1').split('.')
            self.lineEdit_ip_3.setText(ip[0])
            self.lineEdit_ip_2.setText(ip[1])
            self.lineEdit_ip_1.setText(ip[2])
            self.lineEdit_ip_0.setText(ip[3])

            # Set RGB LEDs colours
            for index in range(4):
                colour = preferences.get(
                    f'rgb_{index}', [120, 120, 120])
                self.leds_colors_spin_boxes[index]['r'].setValue(colour[0])
                self.leds_colors_spin_boxes[index]['g'].setValue(colour[1])
                self.leds_colors_spin_boxes[index]['b'].setValue(colour[2])

            # Set builtin led state
            led_builtin_state = preferences.get('led_builtin', True)
            if self.led_builtin_on.toggled and not led_builtin_state:
                self.led_builtin_off.toggle()
            led_builtin_state = 'true' if led_builtin_state else 'false'
            self.command_queue.put(f'{{"led_builtin": {led_builtin_state}}}')

        except (
            FileNotFoundError,
            json.decoder.JSONDecodeError,
        ):
            self.save_preferences(init_spin_boxes=True)
            self.save_preferences(led_builtin=True)
            self.save_preferences(colour_index=0, colour=QColor(120, 120, 120))
            self.save_preferences(colour_index=1, colour=QColor(120, 120, 120))
            self.save_preferences(colour_index=2, colour=QColor(120, 120, 120))
            self.save_preferences(colour_index=3, colour=QColor(120, 120, 120))
            self.load_preferences()

    def save_preferences(
            self, colour_index: int = None, colour: QColor = None,
            led_builtin: bool = None, init_spin_boxes: bool = False) -> None:
        """ Save the application current states. """
        ensure_path(os.path.dirname(PREFERENCES_PATH))

        old_preferences = {}
        try:
            old_preferences = json.load(open(resource_path(PREFERENCES_PATH)))
        except (
            FileNotFoundError,
            json.decoder.JSONDecodeError,
        ):
            print('Error saving preferences, file not found.', file=sys.__stderr__)

        if self.spinBox_left_high_forward.value() > self.pwm_max_value.value():
            self.spinBox_left_high_forward.setValue(self.pwm_max_value.value())
        if self.spinBox_left_high_backward.value() > self.pwm_max_value.value():
            self.spinBox_left_high_backward.setValue(
                self.pwm_max_value.value())
        if self.spinBox_left_low_forward.value() > self.pwm_max_value.value():
            self.spinBox_left_low_forward.setValue(self.pwm_max_value.value())
        if self.spinBox_left_low_backward.value() > self.pwm_max_value.value():
            self.spinBox_left_low_backward.setValue(self.pwm_max_value.value())
        self.spinBox_left_high_forward.setMaximum(
            self.pwm_max_value.value())
        self.spinBox_left_high_backward.setMaximum(
            self.pwm_max_value.value())
        self.spinBox_right_high_forward.setMaximum(
            self.pwm_max_value.value())
        self.spinBox_right_high_backward.setMaximum(
            self.pwm_max_value.value())

        preferences = {
            'pwm_max_value': self.pwm_max_value.value(),
            'inverse_motors': self.checkBox_inverse_motors.isChecked(),
            'inverse_left_motor_direction': self.checkBox_inverse_left_motor_direction.isChecked(),
            'inverse_right_motor_direction': self.checkBox_inverse_right_motor_direction.isChecked(),
            'left_low_forward': self.spinBox_left_low_forward.value(),
            'left_low_backward': self.spinBox_left_low_backward.value(),
            'left_high_forward': self.spinBox_left_high_forward.value(),
            'left_high_backward': self.spinBox_left_high_backward.value(),
            'right_low_forward': self.spinBox_right_low_forward.value(),
            'right_low_backward': self.spinBox_right_low_backward.value(),
            'right_high_forward': self.spinBox_right_high_forward.value(),
            'right_high_backward': self.spinBox_right_high_backward.value(),
            'ip_address': f'{self.lineEdit_ip_3.text()}.{self.lineEdit_ip_2.text()}.{self.lineEdit_ip_1.text()}.{self.lineEdit_ip_0.text()}',
            'port': self.lineEdit_port.text(),
        }

        if init_spin_boxes:
            preferences['left_low_forward'] = 0
            preferences['left_low_backward'] = 0
            preferences['left_high_forward'] = self.pwm_max_value.value()
            preferences['left_high_backward'] = self.pwm_max_value.value()
            preferences['right_low_forward'] = 0
            preferences['right_low_backward'] = 0
            preferences['right_high_forward'] = self.pwm_max_value.value()
            preferences['right_high_backward'] = self.pwm_max_value.value()

        if led_builtin is not None:
            preferences = old_preferences
            led_builtin_state = self.led_builtin_on.isChecked()
            preferences.update({'led_builtin': led_builtin_state})
            led_builtin_state = 'true' if led_builtin_state else 'false'
            self.command_queue.put(f'{{"led_builtin": {led_builtin_state}}}')

        if colour_index is not None and colour is not None:
            # Only alter colours
            preferences = old_preferences
            preferences.update({f'rgb_{colour_index}': (
                colour.red(), colour.green(), colour.blue())})
            self.command_queue.put(
                f'{{"rgb_{colour_index}": [{colour.red()}, {colour.green()}, {colour.blue()}]}}')

        json.dump(old_preferences | preferences, open(PREFERENCES_PATH, 'w'))


# class SettingsWindow(QDialog):
#     """Settings dialog."""

#     def __init__(self, parent=None, path_to_executable=''):
#         super().__init__(parent)
#         # Create an instance of the GUI
#         self.ui = Ui_Settings_dialog()
#         # Run the .setupUi() method to show the GUI
#         self.ui.setupUi(self)
#         self.setWindowTitle('Settings')

#         # Connect signals
#         self.ui.toolButton.clicked.connect(self.select_coh3toedf_path)
#         self.ui.lineEdit.textEdited.connect(self.save_change)
#         # self.ui.accept.clicked.connect(self.check)

#         # Initialise the GUI text
#         self.path_to_executable = path_to_executable
#         self.ui.lineEdit.setText(self.path_to_executable)

#     def accept(self):
#         """Overwrite the accept() method, to validate the settings changes."""
#         if (
#             os.path.exists(self.path_to_executable)
#             and self.path_to_executable.lower().endswith('.exe')
#         ):
#             if validate_executable(self.path_to_executable):
#                 super().accept()
#             else:
#                 self.show_error_message_invalid_executable()

#         else:
#             self.show_error_message_invalid_path()

#     def save_change(self):
#         """ Update the edited text. """
#         self.path_to_executable = self.ui.lineEdit.text()

#     def show_error_message_invalid_path(self):
#         """ Show a warning about the path validity. """
#         msg = QMessageBox()
#         msg.setWindowTitle('Unvalid file path')
#         msg.setIcon(QMessageBox.Icon.Warning)
#         msg.setText(
#             'Please select an existing .exe file.')
#         msg.setStandardButtons(QMessageBox.StandardButton.Ok)
#         msg.exec()

#     def show_error_message_invalid_executable(self):
#         """ Show a warning about the executable hash validity. """
#         msg = QMessageBox()
#         msg.setWindowTitle('Unvalid executable')
#         msg.setIcon(QMessageBox.Icon.Warning)
#         msg.setText(
#             'Please select the right .exe file ("coh3toEDF.exe").')
#         msg.setStandardButtons(QMessageBox.StandardButton.Ok)
#         msg.exec()


if __name__ == '__main__':
    # For Windows set AppID to add an Icon in the taskbar
    # https://stackoverflow.com/questions/1551605/how-to-set-applications-taskbar-icon-in-windows-7
    if sys.platform == 'win32':
        from ctypes import wintypes

        APPID = u'vincent_stragier.elab.v1.0.0'  # arbitrary string
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(APPID)

        lp_buffer = wintypes.LPWSTR()
        ctypes.windll.shell32.GetCurrentProcessExplicitAppUserModelID(
            ctypes.cast(ctypes.byref(lp_buffer), wintypes.LPWSTR))
        # appid = lp_buffer.value
        ctypes.windll.kernel32.LocalFree(lp_buffer)

    app = QApplication(sys.argv)
    # Launch the main app.
    MyApplication = MainApp()
    MyApplication.show()  # Show the form
    icon_path = resource_path('package_data/icon.ico')
    app.setWindowIcon(QIcon(icon_path))
    MyApplication.setWindowIcon(QIcon(icon_path))
    sys.exit(app.exec())  # Execute the app
